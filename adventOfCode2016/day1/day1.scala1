package adventofcode.day1
import scala.util.matching.Regex

sealed trait Step
case class L(size: Int) extends Step
case class R(size: Int) extends Step

case class Vec(x: Int, y: Int, size: Int)

object TaxiCab {
	def convertToVector(dir: Option[Vec], step: Step) : Option[Vec] = {
		(dir, step) match {
			case (Some(Vec(0,1,_)), L(size)) => Some(Vec(-1, 0, size))
			case (Some(Vec(0,1,_)), R(size)) => Some(Vec(1, 0, size))
			case (Some(Vec(-1,0,_)), L(size)) => Some(Vec(0, -1, size))
			case (Some(Vec(-1,0,_)), R(size)) => Some(Vec(0, 1, size))
			case (Some(Vec(0,-1,_)), L(size)) => Some(Vec(1, 0, size))
			case (Some(Vec(0,-1,_)), R(size)) => Some(Vec(-1, 0, size))
			case (Some(Vec(1,0,_)), L(size)) => Some(Vec(0, 1, size))
			case (Some(Vec(1,0,_)), R(size)) => Some(Vec(0, -1, size))
			case (_, _) => None
		}
	}

	def walk(a: Option[Vec], b: Option[Vec]) = {
		Some(Vec(a.get.x * a.get.size + b.get.x * b.get.size,
			a.get.y * a.get.size + b.get.y * b.get.size,
			1))
	}

	def getParsedInput = {
		val path = scala.io.Source.fromFile("input.txt").mkString
		val leftStep = "L(\\d+)".r
		val rightStep = "R(\\d+)".r

		path.split(", ")
			.map({
				case leftStep(length) => L(length.toInt)
				case rightStep(length) => R(length.toInt)
			})
	}

	def getListAbsVectors = {
		getParsedInput
			.scanLeft(Option(Vec(0,1,0)))(convertToVector)
	}

	def task1 = {
		getListAbsVectors
			.reduceLeft(walk)
			.foreach(x => println(x))

	}

	def addVectorsInBetween(a: Seq[Vec], b: Option[Vec]) : Seq[Vec] = {
		if (a.size != 0 && !(a.last.x == b.get.x && a.last.y == b.get.y)) {
			(for {
				x <- a.last.x to b.get.x by (if (a.last.x > b.get.x) -1 else 1)
				y <- a.last.y to b.get.y by (if (a.last.y > b.get.y) -1 else 1)
			} yield Vec(x, y, 0)).drop(1)
		}
		else Seq(b.get)
	}

	case class SetAndVector(set: Set[Vec], v: Vec, seen: Boolean)

	def seen(a: SetAndVector, b: Vec) : SetAndVector = {
		SetAndVector(a.set + b, b, a.set.contains(b))
	}

	def task2 = {
		getListAbsVectors
			.scanLeft(Option(Vec(0,0,0)))(walk)
			.scanLeft(Seq[Vec]())(addVectorsInBetween)
			.flatten
			.scanLeft(SetAndVector(Set(), Vec(0,0,0), false))(seen)
			.filter(_.seen)
			.take(20)
			.foreach(x => println(x.v))

	}

	def main(args: Array[String]): Unit = {
		task2
	}
}